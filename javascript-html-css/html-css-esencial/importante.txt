
/*
    Valores :
    EM -> Equivale al tamaño de fuente establecido en el padre.Si el padre tiene un valor de 20px, 1em tendra el valor de 20, 2em el valor de 40 y asi sucesivamente: 
    Operación matematica el valor se multiplica x el valor establecido en el padre. 
    Ejemplo anidado quer seria practicamente herencia sobre herencia :
    padre{
        fz: 10px;
    hijo{
        fz:1em (10px) | 2em(20px)
    subhijo{
        fz : 2em(40px) -> Se suma o agarra el tamaño que tiene el padre que en este caso seria "hijo" que tiene un valor de 20px ahora el subhijo por defecto obtiene el valor de 20.
*/

EM(Herencia sobre herencia)
body{ (Padre)
    font-size : 20px;
}
h1{
    font-size: 2em;  1em = 20px  | 2em = 40px (padre body por eso 1em sigue valiendo 20px)
}
article{
    font-size: 3em;  3em = 60px (padre body por eso 1em sigue valiendo 20px)
}
article h3 {
    font-size: 2em;  2em = 120 (padre article con el valor de 3em = 60px lo que significa que 1em = 60px , 2em = 120 (60*60))
}

/*REM
  A diferencia de los em toma el valor relativo pero no como los em de herencia en herencia , si no que va tomar el que tenga el valor del elemento mas cercano al ::root, puede ser * , body , html , head etc.*/

    Si el valor establecido por el elemento con un rango alto cerca al :root o el :root es 10px
    1 rem valdra igual 10px asi como el em se va sumando  4rem = 40px , pero la gran diferencia es que si
    declaramos un valor REM dentro de un padre y declaramos de la misma manera otro valor REM dentro de un  hijo
    no se multiplicara con los del padre como lo hace el EM , si no lo hara con el "elemento" de rango mayor que establecio dicho valor.No hay herencia , todo es independiente se multiplican con el elemento de rango alto.


Depurar CSS
    SI queremos hacer pruebas o depurar los estilos.
    Podemos hacer cerando una clase debug y ahi poner los estilos para identificar los elementos.
    Mayormente se depura con Border o Background
    pero existe otra propiedad como outline funciona de la misma manera que border pero con la diferencia de que outline no suma al modelo de caja , podemos utilizar cualquier de los dos pero el caso de border tenemos que siempre utilizar el box-sizing:border-box.


Wrapper ->
Es recomendable encerrar todo el contenido principal dentro de un elemento main.
El main debe contener dos contenedores mas que seria el wrapper y main-content.

Funciones:
    -Main -> contenedor principal , podemos darle backgrounds o solo contener 
    -wrapper -> Encargado del ancho y margin. Delimita las fronteras de nuestro contenido
    -main-content ->Podemos darle los estlos al contenido como padding, background etc.
Con todo esto utilizando el metodo wrapper nos ayuda a no romper nuestra contenido , flujo o arquitecutra.